package GeneticA;

import java.io.FileWriter;
import java.io.IOException;
import java.util.*;
import Core.Pentominoes;
import Core.Rotations;
import Core.UserVariables;

public class DepthSearch {
    public static Pentominoes PentP;
    public static Pentominoes PentT;
    public static Pentominoes PentL;
    public static Pentominoes ParcelA;
    public static Pentominoes ParcelB;
    public static Pentominoes ParcelC;
    public static int SkippedSpaces = 5;
    public static int BackTrackingAttempts = 0;
    public static int MaximumAttempts = 100;
    public static boolean PlacedSuccess = true;
    public static boolean BackTracking = false;
    public static int IA;
    public static int JA;
    public static int score = 0;
    public static int Bestscore = 0;
    public static Stack<int[][]> StackBarbuc = new Stack<int[][]>();
    static ArrayList<Pentominoes> AllPentominoes;
    public static Stack<int[][]> stackAuPoivre = new Stack<int[][]>();

    public static void main(String[] args) throws IOException {
        InitialisePento();
        ArrayList<Integer> Arr = new ArrayList<Integer>();
        Arr.add(187); // C
        Arr.add(35); // B
        Arr.add(12); // A
        depthSearching(Arr);
        System.out.println(Arrays.deepToString(UserVariables.container));
    }

    // Code block to test the impact of the attempts of backtracking, and number of
    // skipped spaces
    // FileWriter csvFile = new FileWriter("BackTrackingParcelsandSS.csv");
    // List<Integer> storage = new ArrayList<>();

    // int[] storageReal = new int[3];
    // int a;
    // String b;
    // PopulationLea.InitializePop();
    // InitialiseParcels(); // initiliasePento

    // for (int y = 1; y < 6; y++) {
    // long startTime = System.nanoTime();
    // csvFile.write("--------I'm the SS " + y + " ----------");
    // SkippedSpaces = y;

    // for (int j = 1; j < 1000000; j *= 10) {
    // MaximumAttempts = j;
    // csvFile.write("--------Im the attempt " + j + " of backtracking--------" +
    // "\n");

    // for (int i = 0; i < 50; i++) {
    // storageReal = depthSearching(PopulationLea.Population.get(i));
    // a = storageReal[2]; // [2] corresponds to the result
    // b = Integer.toString(a);
    // csvFile.append(b);
    // csvFile.append("\n");
    // }
    // long endTime = System.nanoTime();
    // long totalTime = endTime - startTime;
    // csvFile.write("-------------------I took " + totalTime + " to
    // run---------------------" + "\n");
    // }
    // }
    // csvFile.close();
    // System.out.println(Arrays.deepToString(UserVariables.container));
    // }

    // To get value and rotations for Pentominoe objects
    // The number of each type of Pento is not actually used because we use the
    // numbers generated by the GA
    public static ArrayList<Pentominoes> InitialisePento() {
        AllPentominoes = new ArrayList<Pentominoes>();
        PentL = new Pentominoes("L", Rotations.getL(), 3, 0);
        PentP = new Pentominoes("P", Rotations.getP(), 4, 54); // second highest volume/value ratio
        PentT = new Pentominoes("T", Rotations.getT(), 5, 210); // highest volume/value ratio
        AllPentominoes.add(PentT);
        AllPentominoes.add(PentP);
        AllPentominoes.add(PentL);
        return AllPentominoes;
    }

    // I actually store my Parcels into a Pentominoe object, because they both have
    // the same constructor, so I don't have to do any modifications on my classes
    public static ArrayList<Pentominoes> InitialiseParcels() {
        AllPentominoes = new ArrayList<Pentominoes>();
        ParcelA = new Pentominoes("A", Rotations.getA(), 3, 0);
        ParcelB = new Pentominoes("B", Rotations.getB(), 4, 54);
        ParcelC = new Pentominoes("C", Rotations.getC(), 5, 210);
        AllPentominoes.add(ParcelC);
        AllPentominoes.add(ParcelB);
        AllPentominoes.add(ParcelA);
        return AllPentominoes;
    }

    public static int[] depthSearching(ArrayList<Integer> b) {
        BackTrackingAttempts = 0;
        Bestscore = 0;
        score = 0;
        StackBarbuc = new Stack<int[][]>();
        stackAuPoivre = new Stack<int[][]>();
        // Pass values of chromosomes into the Pentominoes
        for (int z = 0; z < b.size(); z++) {
            Pentominoes temp = AllPentominoes.get(z);
            Integer a = b.get(z);
            temp.setAmount(a);
            // For negative values in Chromosome, penalize the chromosome
            if (a < 0) {
                int[] result = { -10000, 0, 0 };
                return result;
            }
        }
        EmptyContainer();
        for (int k = 0; k < UserVariables.container.length; k++) {
            for (int l = 0; l < UserVariables.container[0].length; l++) {
                for (int m = 0; m < UserVariables.container[0][0].length; m++) {
                    int[] position = { k, l, m };
                    int i;
                    int j;
                    if (UserVariables.container[k][l][m] == 0) { // true, as long as there is still space in container
                        for (i = 0; i < AllPentominoes.size(); i++) {
                            if (UserVariables.container[k][l][m] != 0) { // will be the case then break and goes to end
                                                                         // of loop i
                                break;
                            }
                            if (AllPentominoes.get(i).getAmount() <= 0) { // changing the type of pentominoe
                                continue;
                            }
                            for (j = 0; j < AllPentominoes.get(i).getRotation().length; j++) {
                                if (m > UserVariables.container[0][0].length - 1) {
                                    break;
                                }

                                if (BackTracking) {

                                    if (JA < AllPentominoes.get(i).getRotation().length) {
                                        i = IA;
                                        j = JA;

                                    } else {
                                        if (IA < AllPentominoes.size() - 1) {
                                            i = IA + 1;
                                            j = 0;
                                        } else {
                                            i = 0;
                                            j = -1;
                                            m = (m + 1) % UserVariables.container[0][0].length;
                                            BackTracking = false;
                                            continue;
                                        }
                                        if (AllPentominoes.get(i).getAmount() <= 0) { // changing the type of pentominoe
                                            BackTracking = false;
                                            break;
                                        }
                                    }
                                    BackTracking = false;
                                }

                                if (UserVariables.container[k][l][m] != 0) { // will be the case, then break and goes to
                                                                             // next iteration of i
                                    break;
                                }
                                // If not possible to put pento at current position, then try n number of time
                                // later : varying the parameter m
                                for (int n = 0; n < SkippedSpaces; n++) {
                                    int sum = m + n;
                                    int[] positionSkip = { k, l, sum };
                                    int[] piecesAndRotations = { i, j };

                                    if (addParcel(AllPentominoes.get(i).getRotation()[j], positionSkip,
                                            piecesAndRotations) && AllPentominoes.get(i).getAmount() > 0) { // try to
                                                                                                            // put a
                                                                                                            // pento, if
                                                                                                            // succeed,
                                                                                                            // break and
                                                                                                            // goes to
                                                                                                            // next
                                                                                                            // iteration
                                                                                                            // of j
                                        AllPentominoes.get(i).setAmount(AllPentominoes.get(i).getAmount() - 1);
                                        // If false, goes to next iteration of skipped space, then goes to j and try
                                        // differnt rotation
                                        int[][] a = { { k, l, sum }, { i, j } };
                                        stackAuPoivre.push(a);
                                        score += AllPentominoes.get(i).getValue();
                                        break;
                                    }
                                }
                            }
                        }
                    }

                    int[] LastTrip = { UserVariables.container.length - 1, UserVariables.container[0].length - 1,
                            UserVariables.container[0][0].length - 1 };
                    if (Arrays.equals(position, LastTrip) && MaximumAttempts > BackTrackingAttempts) { // We only access
                                                                                                       // here when
                                                                                                       // there are no
                                                                                                       // positions left
                                                                                                       // in container
                                                                                                       // and we still
                                                                                                       // have
                                                                                                       // backtracking
                                                                                                       // attempst
                                                                                                       // remaining
                        if (score > Bestscore) {
                            Bestscore = score;
                            StackBarbuc = (Stack<int[][]>) stackAuPoivre.clone(); // best stack becomes current stack
                        }
                        int[][] removeMove = stackAuPoivre.pop(); // removing last element on stack
                        // First array contains coordinate, and second the piece and rotation
                        // Going back to coordinates of piece we want to remove
                        k = removeMove[0][0];
                        l = removeMove[0][1];
                        m = removeMove[0][2];
                        i = removeMove[1][0];
                        j = removeMove[1][1];
                        int[] positionA = { k, l, m };
                        BackTrackingAttempts++;
                        removePiece(AllPentominoes.get(i).getRotation()[j], positionA);

                        IA = i;
                        JA = j + 1;
                        BackTracking = true;
                        score -= AllPentominoes.get(i).getValue();
                        AllPentominoes.get(i).setAmount(AllPentominoes.get(i).getAmount() + 1); // since we just removed
                                                                                                // a pento, we increase
                                                                                                // the number available
                                                                                                // again

                    }
                }
            }
        }
        EmptyContainer(); // only filling container with the best solution, so we empty the rest
        Iterator value = StackBarbuc.iterator();
        int NbofT = 0;
        int NbofP = 0;
        int NbofL = 0;
        int stempScore = 0;
        while (value.hasNext()) {
            int[][] popped = StackBarbuc.pop();
            int[] positionPiece = { popped[0][0], popped[0][1], popped[0][2] };
            addParcel(AllPentominoes.get(popped[1][0]).getRotation()[popped[1][1]], positionPiece, popped[1]);
            if (popped[1][0] == 0) {
                stempScore += 5;
                NbofT++;
            } else if (popped[1][0] == 1) {
                stempScore += 4;
                NbofP++;
            } else if (popped[1][0] == 2) {
                stempScore += 3;
                NbofL++;
            }
        }
        int fitScore = (stempScore - ((b.get(0) - NbofT) * 5 + (b.get(1) - NbofP) * 4 + (b.get(2) - NbofL) * 3));
        int Volume = ((NbofT + NbofL + NbofP) * 5);
        int[] resultGA = new int[3];
        resultGA[0] = fitScore;
        resultGA[1] = Volume;
        resultGA[2] = stempScore;
        System.out.println("Score StackScore : " + stempScore);
        System.out.println("Best score: " + Bestscore);
        System.out.println("Number of Pentoes : [" + " T : " + NbofT + " P : " + NbofP + " L : " + NbofL + " ]");
        System.out.println("Number of Pentoes left : [" + " T : " + (b.get(0) - NbofT) + " P : " + (b.get(1) - NbofP)
                + " L : " + (b.get(2) - NbofL) + " ]");
        // when printing the inside of the container here, there is nothing inside....
        // saddddd
        return resultGA;
    }

    /**
     * 
     * @param parcel:             piece to be added to the container, can be either
     *                            parcel or pentominoe
     * @param position:           position in the container where piece is added
     *                            (stores the x,y,z coordinates)
     * @param PiecesAndRotations: store first the ID of the piece, then its rotation
     *                            index
     * @param filling:            coloring the container at the location where we
     *                            add a piece
     */
    public static boolean addParcel(int[][][] parcel, int[] position, int[] PiecesAndRotations) {
        int PieceID = PiecesAndRotations[0];
        int RotationID = PiecesAndRotations[1];

        if (checkEmpty(parcel, position)) {
            for (int i = 0; i < parcel.length; i++) {
                for (int j = 0; j < parcel[i].length; j++) {
                    for (int k = 0; k < parcel[i][j].length; k++) {
                        if (parcel[i][j][k] != 0) {
                            UserVariables.container[position[0] + i][position[1] + j][position[2] + k] = PieceID + 1;
                            // System.out.println(PieceID);

                        }
                    }
                }
            }

            return true;
        }
        return false;
    }

    public static void EmptyContainer() {
        for (int x = 0; x < UserVariables.container.length; x++) {
            for (int y = 0; y < UserVariables.container[0].length; y++) {
                for (int z = 0; z < UserVariables.container[0][0].length; z++) {
                    UserVariables.container[x][y][z] = 0;
                }
            }
        }
    }

    public static void removePiece(int[][][] piece, int[] position) {
        for (int i = 0; i < piece.length; i++) {
            for (int j = 0; j < piece[i].length; j++) {
                for (int k = 0; k < piece[i][j].length; k++) {
                    if (piece[i][j][k] != 0) {
                        UserVariables.container[position[0] + i][position[1] + j][position[2] + k] = 0;

                    }
                }
            }
        }
    }

    /**
     * 
     * @param parcel:   piece to add to the container, parcel or pentominoe
     * @param position: location where to add piece in container
     * @return: return true if we can indeed put the piece in the intended location
     */
    public static boolean checkEmpty(int[][][] parcel, int[] position) {
        if (position[0] < 0 || position[1] < 0 || position[2] < 0) {
            return false;
        } else if (position[0] + parcel.length > UserVariables.container.length) {
            return false;
        } else if (position[1] + parcel[0].length > UserVariables.container[0].length) {
            return false;
        } else if (position[2] + parcel[0][0].length > UserVariables.container[0][0].length) {
            return false;
        } else {
            for (int i = 0; i < parcel.length; i++) {
                for (int j = 0; j < parcel[i].length; j++) {
                    for (int k = 0; k < parcel[i][j].length; k++) {
                        if (parcel[i][j][k] != 0) { // because pentominoes have holes, so no need to check for holes lol
                            if (UserVariables.container[position[0] + i][position[1] + j][position[2] + k] != 0) {
                                return false;
                            }

                        }
                    }
                }
            }
        }
        return true;
    }
}